### On Working Backwards


According to the Amazon Unbound, in the early days of Alexa, the product team faced a dilemma. To make the product good, they would need a lot of data to fuel the deep learning approach behind Alexa's speech recognition, yet they had neither single customer nor the prototype to draw data from. The team brought up the issue and proposed the solutions to the then CEO, Jeff Bezos. But the CEO stood up and said "You guys aren't serious about making this product," and abruptly ended the meeting. He also said, "You are going about this the wrong way. First tell me what would be a magical product, then tell me how to get there." That's the crux of working backwards.

In my line of work as a developer, working backwards has helped separating a good solution design from a sloppy one and saved me the troubles sending apologies and bandaging the process when the outcomes were not expected. I don't mean that developers need to write a 6-page narrative like Amazonians do in the form of a press release to envision the market impact of the product. But consider writing the handbook before writing a single line of code. We developers tend to get hung up on thorny technical problem before deciding on what we were really building. First decide what would be a magical bot. And that requires summoning every bit of imagination.

I has relied often on the essential tools in conjuring what I would be building. Good for us that there is nothing fancy about the technology marketed as robotic process automation (RPA). Queues, schedules and data are our only chess pieces. Developers must therefore ask: how would I orchestrate these pieces to meet the ultimate goal: having bots do the work my sponsors have been doing? Like in chess, the opponent will not sit still and let us knock all the pieces. Our opponents are the quality of data, the states of applications and even our own blind spots. Thus to answer how to get there part, we must not only know the proper use of each pieces but also anticipate the obstacles along the way.

Working backwards also meant looking at the as-is process with curious eyes. Remember the ultimate goal is having the bots do the work, not doing the work the way our sponsors do. Many times I have seen developers put unnecessary constraints on themselves by following the as-is process to the letters. In the process of figuring out how to get there, separate the what need to be done from how they are currently done from the requirements. Nothing more frustrating and unfortunate than spending days developing and testing on a piece of codes to meet a requirement that is not needed to get to the final outcome. Working backwards requires holding on to the what while constantly probing the how.

In this day and age, coding is only going to get easier. The birth of RPA field is by itself an example. Before RPA, a developer would have to write macros or stand-alone command-line scripts to automate digital tasks. With RPA, he or she would only need to drag and drop pre-built code blocks. What used to take hours now take minutes. Naturally this trend would upset many developers who fear that they would be automated one day. Yet in my team we could not have enough those who work backwards. Perhaps to do so, we developers must see ourselves less as followers but more as shapers of modern enterprise work.